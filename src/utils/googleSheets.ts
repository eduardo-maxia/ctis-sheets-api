import { GoogleSpreadsheet, GoogleSpreadsheetRow } from 'google-spreadsheet';
import { JWT } from 'google-auth-library'
import { processPayments } from './bancoInter';

function compareCpf(cpfMasked: string, cpfReduced: string) {
  return cpfMasked.replace(/\D/g, '') === cpfReduced.replace(/\D/g, '')
}

async function getSheet() {
  const GCLOUD_SERVICE_ACCOUNT = process.env.GCLOUD_SERVICE_ACCOUNT
  // Decode the base64 key file
  const buff = Buffer.from(GCLOUD_SERVICE_ACCOUNT!, 'base64');
  const keys = JSON.parse(buff.toString('ascii'));

  // Initialize auth - see https://theoephraim.github.io/node-google-spreadsheet/#/guides/authentication
  const serviceAccountAuth = new JWT({
    // env var values here are copied from service account credentials generated by google
    // see "Authentication" section in docs for more info
    // email: process.env.GCLOUD_SERVICE_ACCOUNT_EMAIL,
    // key: process.env.GCLOUD_PRIVATE_KEY,
    email: keys.client_email,
    key: keys.private_key,
    scopes: [
      'https://www.googleapis.com/auth/spreadsheets',
    ],
  });
  const doc = new GoogleSpreadsheet(process.env.SHEET_ID!, serviceAccountAuth);

  await doc.loadInfo(); // loads document properties and worksheets

  return doc
}

export async function gerarPagamentos() {
  const doc = await getSheet()

  // Get month to generate
  const gestaoSheet = doc.sheetsByTitle['Gestão'];
  await gestaoSheet.loadCells('A4')
  const month = gestaoSheet.getCellByA1('A4').stringValue

  if (!month) return

  // Now generate the payments by iterating over all active students and creating a new row for each one
  // Get all active students
  let activeStudents: GoogleSpreadsheetRow<Record<string, any>>[] = []

  // 2-13: Máximo de 12 alunos
  await Promise.all(doc.sheetsByIndex.map(async (sheet) => {
    if (sheet.title === 'Gestão' || sheet.title === 'Pagamentos' || sheet.title === 'Não Identificados') return
    await sheet.loadCells('A2:O13')
    const rows = await sheet.getRows({ limit: 12 });
    activeStudents.push(...rows.filter(row => row.get('Nome')?.length > 0))
  }))


  // Now go to the payments sheet to generate all payments
  const paymentsSheet = doc.sheetsByTitle['Pagamentos'];
  const allPayments = await paymentsSheet.getRows()

  async function generateStudentPayment(index: number) {
    const student = activeStudents[index]
    if (!student) return

    // Before adding the payment, check if it already exists
    if (allPayments.filter(p => p.get('TurmaReferencia') === student._worksheet.title
      && p.get('MesReferencia') === month && p.get('Nome') === student.get('Nome')
    ).length > 0) return Promise.resolve()

    await paymentsSheet.addRow({
      Nome: student.get('Nome'),
      CPF: student.get('CPF'),
      DataVencimento: student.get('DataVencimento'),
      MesReferencia: month!,
      TurmaReferencia: student._worksheet.title,
      Status: 'PENDENTE'
    }).then(pagamento => {
      // Create the link between the payment on this table and the original visialization table
      student.set(month!, `=Pagamentos!F${pagamento.rowNumber}`)
      student.save()
    })

    return generateStudentPayment(index + 1)
  }

  await generateStudentPayment(0)
}

export async function updatePayments() {
  const doc = await getSheet()

  const gestaoSheet = doc.sheetsByTitle['Gestão'];
  await gestaoSheet.loadCells('Q29')
  const last_processed_tx_cell = gestaoSheet.getCellByA1('Q29')

  const { paymentsToUpdate, last_processed_tx } = await processPayments(
    typeof last_processed_tx_cell.value === 'string' ? last_processed_tx_cell.value : null
  )

  const paymentsSheet = doc.sheetsByTitle['Pagamentos'];
  const paymentsRows = await paymentsSheet.getRows()
  paymentsToUpdate.forEach(async ({ transaction_id, nome, cpf, valor, dataPagamento }) => {
    // Find the payment corresponding to this processed payment
    const numberOfPaymentsToClear = Math.floor(valor / 130)
    const paymentRows = paymentsRows.filter(row => compareCpf(row.get('CPF'), cpf) && row.get('Status') === 'PENDENTE')
      .slice(0, numberOfPaymentsToClear)

    // If numberOfPaymentsToClear is lengthier than paymentRows found, we have an unidentified payment
    if (numberOfPaymentsToClear > paymentRows.length) {
      console.log('Unidentified payment')
      const naoIdentificadosSheet = doc.sheetsByTitle['Não Identificados'];
      await naoIdentificadosSheet.addRow({
        Nome: nome,
        CPF: cpf,
        Valor: valor,
        DataPagamento: dataPagamento,
        TxId: transaction_id
      })
      return
    }

    // Now update the actually processed payments
    const promises = paymentRows.map(async row => {
      row.set('Status', 'PAGO')
      row.set('DataPagamento', dataPagamento)
      row.set('TxId', transaction_id)
      row.set('CPFPagador', cpf)
      row.set('ProcessadoPelaApi', true)
      row.save()
    })
    await Promise.all(promises)
  })

  last_processed_tx_cell.value = last_processed_tx
  last_processed_tx_cell.save()
}

