import { GoogleSpreadsheet, GoogleSpreadsheetRow } from 'google-spreadsheet';
import { JWT } from 'google-auth-library'
import { processPayments } from './bancoInter';
import { isUndefined } from 'lodash';

function powerset<T>(arr: T[]): T[][] {
  var ps: T[][] = [[]];
  for (var i = 0; i < arr.length; i++) {
    for (var j = 0, len = ps.length; j < len; j++) {
      ps.push(ps[j].concat(arr[i]));
    }
  }
  return ps;
}

function sum(arr: any[]) {
  var total = 0;
  for (var i = 0; i < arr.length; i++)
    total += arr[i];
  return total
}


function getPaymentSubset<T extends GoogleSpreadsheetRow>(pagamentos: T[], targetSum: number): T[] | null {
  var pagamentosSets = powerset(pagamentos);
  for (var i = 0; i < pagamentosSets.length; i++) {
    var pagamentoSet = pagamentosSets[i];
    if (sum(pagamentoSet.map(p => Number(p.get('Valor').split('R$')[1].replace(',', '.')))) === targetSum)
      return pagamentoSet;
  }

  return null
}

const getA1Notation = (row: number, column: number) => {
  const a1Notation = [`${row}`];
  const totalAlphabets = 'Z'.charCodeAt(0) - 'A'.charCodeAt(0) + 1;
  let block = column;
  while (block >= 0) {
    a1Notation.unshift(String.fromCharCode((block % totalAlphabets) + 'A'.charCodeAt(0)));
    block = Math.floor(block / totalAlphabets) - 1;
  }
  return a1Notation.join('');
};

function compareCpf(cpfMasked: string, cpfReduced: string) {
  const cpfs = cpfReduced.split(';').map(cpf => cpf.trim().replace(/\D/g, ''))
  return cpfs.includes(cpfMasked.trim().replace(/\D/g, ''))
}

function compareNome(nomePagamento: string, nomeReferencias: string) {
  const listaNomes = String(nomeReferencias).split(';').map(nome => nome.trim().toLowerCase()).filter(el => el !== '')
  return listaNomes.includes(nomePagamento.trim().toLowerCase())
}

function compareDates(MesReferencia: string, DataPagamento: string) {
  const month = MesReferencia.split('(')[0].trim()
  const year = MesReferencia.split('(')[1].split(')')[0]

  const [paymentMonth, paymentYear] = new Date(DataPagamento.split('/').reverse().join('/')).toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' }).split(' de ')
  return month.toLowerCase() === paymentMonth.toLowerCase() && year === paymentYear
}

async function getSheet() {
  const GCLOUD_SERVICE_ACCOUNT = process.env.GCLOUD_SERVICE_ACCOUNT
  // Decode the base64 key file
  const buff = Buffer.from(GCLOUD_SERVICE_ACCOUNT!, 'base64');
  const keys = JSON.parse(buff.toString('ascii'));

  // Initialize auth - see https://theoephraim.github.io/node-google-spreadsheet/#/guides/authentication
  const serviceAccountAuth = new JWT({
    // env var values here are copied from service account credentials generated by google
    // see "Authentication" section in docs for more info
    // email: process.env.GCLOUD_SERVICE_ACCOUNT_EMAIL,
    // key: process.env.GCLOUD_PRIVATE_KEY,
    email: keys.client_email,
    key: keys.private_key,
    scopes: [
      'https://www.googleapis.com/auth/spreadsheets',
    ],
  });
  const doc = new GoogleSpreadsheet(process.env.SHEET_ID!, serviceAccountAuth);
  await doc.loadInfo(); // loads document properties and worksheets
  return doc
}

export async function gerarPagamentos() {
  const doc = await getSheet()

  // Get month to generate
  const gestaoSheet = doc.sheetsByTitle['Gestão'];
  await gestaoSheet.loadCells('A4')
  await gestaoSheet.loadCells('A6')
  const month = gestaoSheet.getCellByA1('A4').stringValue
  const year = gestaoSheet.getCellByA1('A6').numberValue
  const monthYear = `${month}(${year})`

  if (!month || !year) return

  // Now generate the payments by iterating over all active students and creating a new row for each one
  // Get all active students
  let activeStudents: GoogleSpreadsheetRow<Record<string, any>>[] = []

  // 2-13: Máximo de 12 alunos, TODO: Turma infantil
  await Promise.all(doc.sheetsByIndex.map(async (sheet) => {
    if (sheet.title === 'Gestão' || sheet.title === 'Pagamentos' || sheet.title === 'Não Identificados') return
    // await sheet.loadCells('A2:C13')
    const rows = await sheet.getRows({ limit: 30 });
    activeStudents.push(...rows.filter(row => row.get('Nome') !== '---' && row.get('Nome')?.length > 0))

    // Verifica se esse mês já foi colocado na planilha. Se não foi, coloca.
    const header = sheet.headerValues
    if (!header.includes(monthYear)) {
      await sheet.setHeaderRow([...header, monthYear])
    }
  }))

  // Now go to the payments sheet to generate all payments
  const paymentsSheet = doc.sheetsByTitle['Pagamentos'];
  const allPayments = await paymentsSheet.getRows()

  const studentsToGenerate = activeStudents.filter(student => allPayments.filter(p => p.get('TurmaReferencia') === student._worksheet.title
    && p.get('MesReferencia') === monthYear && p.get('Nome') === student.get('Nome')
  ).length === 0)
  const studentsInputs = studentsToGenerate.map(student => ({
    Nome: student.get('Nome'),
    CPF: student.get('CPF'),
    Valor: student.get('Mensalidade'),
    DataVencimento: [student.get('DataVencimento'), month, year].join('/'),
    MesReferencia: monthYear,
    TurmaReferencia: student._worksheet.title
  }))

  const generatedPayments = await paymentsSheet.addRows(studentsInputs)
  await paymentsSheet.loadCells('G2:G')
  await Promise.all(generatedPayments.map(async (pagamento, index) => {
    const student = studentsToGenerate[index]
    paymentsSheet.getCellByA1(`G${pagamento.rowNumber}`).value = `=IFS(H${pagamento.rowNumber}<>""; "PAGO"; HOJE() - D${pagamento.rowNumber} > 5; "ATRASADO"; TRUE; "PENDENTE")`

    // Create the link between the payment on this table and the original visialization table
    const columnNumber = student._worksheet.headerValues.findIndex(h => h === monthYear)
    const studentPagamentoA1 = getA1Notation(student.rowNumber, columnNumber)
    await student._worksheet.loadCells(studentPagamentoA1)
    student._worksheet.getCellByA1(studentPagamentoA1).value = `=Pagamentos!G${pagamento.rowNumber}`
  }))

  await paymentsSheet.saveUpdatedCells()
  await Promise.all(doc.sheetsByIndex.map(async (sheet) => {
    if (sheet.title === 'Gestão' || sheet.title === 'Pagamentos' || sheet.title === 'Não Identificados') return

    await sheet.saveUpdatedCells()
  }))
}

export async function updatePayments() {
  const doc = await getSheet()

  const gestaoSheet = doc.sheetsByTitle['Gestão'];
  await gestaoSheet.loadCells('Y115')
  const last_processed_tx_cell = gestaoSheet.getCellByA1('Y115')

  const { paymentsToUpdate, last_processed_tx } = await processPayments(
    typeof last_processed_tx_cell.value === 'string' ? last_processed_tx_cell.value : null
  )

  const paymentsSheet = doc.sheetsByTitle['Pagamentos'];
  const paymentsRows = await paymentsSheet.getRows()
  let unidentifiedPayments: typeof paymentsToUpdate = []
  let justProcessedPayments: number[] = []

  paymentsToUpdate.forEach(async pagamento => {
    // Find the payment corresponding to this processed payment
    const paymentsRowsFiltered = paymentsRows.filter(row =>
      isUndefined(row.get('DataPagamento')) &&
      compareCpf(pagamento.CPF, row.get('CPF')) &&
      compareDates(row.get('MesReferencia'), pagamento.DataPagamento) &&
      !justProcessedPayments.includes(row.rowNumber)
    )
    // Verifica se existe alguma combinação das linhas que satisfaça o valor do pagamento realizado.
    // Se não existir, é um pagamento não identificado.
    // Estratégia: Para montar uma combinação, cada pagamento encontrado estará na combinação final ou não. (true/false)
    // O número de combinações possíveis é 2 ^ paymentsRowsFiltered.length
    const paymentSubset = getPaymentSubset(paymentsRowsFiltered, pagamento.Valor)

    // If numberOfPaymentsToClear is lengthier than paymentsRowsFiltered found, we have an unidentified payment
    if (!paymentSubset) {
      console.log('Unidentified payment')
      unidentifiedPayments.push(pagamento)
      return
    }

    // Now update the actually processed payments
    const promises = paymentSubset.map(async row => {
      justProcessedPayments.push(row.rowNumber)
      await paymentsSheet.loadCells(`H${row.rowNumber}:K${row.rowNumber}`)
      paymentsSheet.getCellByA1(`H${row.rowNumber}`).value = pagamento.DataPagamento
      paymentsSheet.getCellByA1(`I${row.rowNumber}`).value = pagamento.TxId
      paymentsSheet.getCellByA1(`J${row.rowNumber}`).value = pagamento.CPF
      paymentsSheet.getCellByA1(`K${row.rowNumber}`).value = true
    })
    await Promise.all(promises)
    await paymentsSheet.saveUpdatedCells()
  })

  const naoIdentificadosSheet = doc.sheetsByTitle['Não Identificados'];
  await naoIdentificadosSheet.addRows(unidentifiedPayments)

  last_processed_tx_cell.value = last_processed_tx
  last_processed_tx_cell.save()
}

export async function updatePaymentsV2() {
  const doc = await getSheet()

  const gestaoSheet = doc.sheetsByTitle['Gestão'];
  await gestaoSheet.loadCells('Y116')
  const lastProcessedDate = gestaoSheet.getCellByA1('Y116').stringValue ?? '2021-01-01'

  const importacaoSheet = doc.sheetsByTitle['Importação']
  await importacaoSheet.loadCells('B3')
  const datasImportacao = importacaoSheet.getCellByA1('B3').stringValue ?? ''
  const dataInicial = datasImportacao.split(' ')[0]
  const dataFinal = datasImportacao.split(' ')[2]

  if (new Date(dataInicial) <= new Date(lastProcessedDate)) {
    throw new Error('Já foram processados pagamentos para essas datas')
  }

  const paymentsSheet = doc.sheetsByTitle['Pagamentos'];
  const paymentsRows = await paymentsSheet.getRows()
  let unidentifiedPayments: any[] = []
  let justProcessedPayments: number[] = []

  importacaoSheet.setHeaderRow(['DataPagamento', 'Tipo', 'Nome', 'Valor'])
  const novosPagamentos = await importacaoSheet.getRows({ offset: 4 }).then(d => d.filter(row => row.get('Tipo') === 'Pix recebido'))

  novosPagamentos.forEach(async novoPagamento => {
    if (Number(novoPagamento.get('Valor')) < 90) return
    // Find the payment corresponding to this processed payment
    const paymentsRowsFiltered = paymentsRows.filter(row =>
      isUndefined(row.get('DataPagamento')) &&
      compareNome(String(novoPagamento.get('Nome')), row.get('NomeReferencias')) &&
      compareDates(row.get('MesReferencia'), novoPagamento.get('DataPagamento')) &&
      !justProcessedPayments.includes(row.rowNumber)
    )

    // Verifica se existe alguma combinação das linhas que satisfaça o valor do pagamento realizado.
    // Se não existir, é um pagamento não identificado.
    // Estratégia: Para montar uma combinação, cada pagamento encontrado estará na combinação final ou não. (true/false)
    // O número de combinações possíveis é 2 ^ paymentsRowsFiltered.length
    const paymentSubset = getPaymentSubset(paymentsRowsFiltered, Number(novoPagamento.get('Valor')))

    // If numberOfPaymentsToClear is lengthier than paymentsRowsFiltered found, we have an unidentified payment
    if (!paymentSubset) {
      console.log('Unidentified payment')
      unidentifiedPayments.push([novoPagamento.get('Nome'), novoPagamento.get('Valor'), novoPagamento.get('DataPagamento')])
      return
    }

    // Now update the actually processed payments
    const promises = paymentSubset.map(async row => {
      justProcessedPayments.push(row.rowNumber)
      await paymentsSheet.loadCells(`H${row.rowNumber}:I${row.rowNumber}`)
      paymentsSheet.getCellByA1(`H${row.rowNumber}`).value = novoPagamento.get('DataPagamento')
      paymentsSheet.getCellByA1(`I${row.rowNumber}`).value = true
    })
    await Promise.all(promises)
    await paymentsSheet.saveUpdatedCells()
  })

  const naoIdentificadosSheet = doc.sheetsByTitle['Não Identificados'];
  await naoIdentificadosSheet.addRows(unidentifiedPayments)

  // gestaoSheet.getCellByA1('Y116').stringValue = dataFinal
  // gestaoSheet.getCellByA1('Y116').save()
}
