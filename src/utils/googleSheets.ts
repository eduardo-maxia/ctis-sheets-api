import { GoogleSpreadsheet, GoogleSpreadsheetRow } from 'google-spreadsheet';
import { JWT } from 'google-auth-library'
import { processPayments } from './bancoInter';
import { isUndefined } from 'lodash';

const valorMensalidade = 130

function compareCpf(cpfMasked: string, cpfReduced: string) {
  const cpfs = cpfReduced.split(';').map(cpf => cpf.trim().replace(/\D/g, ''))
  return cpfs.includes(cpfMasked.trim().replace(/\D/g, ''))
}

function compareDates(MesReferencia: string, DataPagamento: string) {
  const month = MesReferencia.split('(')[0]
  const year = MesReferencia.split('(')[1].split(')')[0]

  const [paymentMonth, paymentYear] = new Date(DataPagamento).toLocaleDateString('pt-BR', { month: 'long', year: 'numeric' }).split(' de ')
  return month.toLowerCase() === paymentMonth.toLowerCase() && year === paymentYear
}

async function getSheet() {
  const GCLOUD_SERVICE_ACCOUNT = process.env.GCLOUD_SERVICE_ACCOUNT
  // Decode the base64 key file
  const buff = Buffer.from(GCLOUD_SERVICE_ACCOUNT!, 'base64');
  const keys = JSON.parse(buff.toString('ascii'));

  // Initialize auth - see https://theoephraim.github.io/node-google-spreadsheet/#/guides/authentication
  const serviceAccountAuth = new JWT({
    // env var values here are copied from service account credentials generated by google
    // see "Authentication" section in docs for more info
    // email: process.env.GCLOUD_SERVICE_ACCOUNT_EMAIL,
    // key: process.env.GCLOUD_PRIVATE_KEY,
    email: keys.client_email,
    key: keys.private_key,
    scopes: [
      'https://www.googleapis.com/auth/spreadsheets',
    ],
  });
  const doc = new GoogleSpreadsheet(process.env.SHEET_ID!, serviceAccountAuth);
  await doc.loadInfo(); // loads document properties and worksheets
  return doc
}

export async function gerarPagamentos() {
  const doc = await getSheet()

  // Get month to generate
  const gestaoSheet = doc.sheetsByTitle['Gestão'];
  await gestaoSheet.loadCells('A4')
  await gestaoSheet.loadCells('A6')
  const month = gestaoSheet.getCellByA1('A4').stringValue
  const year = gestaoSheet.getCellByA1('A6').numberValue
  const monthYear = `${month}(${year})`

  if (!month || !year) return

  // Now generate the payments by iterating over all active students and creating a new row for each one
  // Get all active students
  let activeStudents: GoogleSpreadsheetRow<Record<string, any>>[] = []

  // 2-13: Máximo de 12 alunos
  await Promise.all(doc.sheetsByIndex.map(async (sheet) => {
    if (sheet.title === 'Gestão' || sheet.title === 'Pagamentos' || sheet.title === 'Não Identificados') return
    await sheet.loadCells('A2:C13')
    const rows = await sheet.getRows({ limit: 12 });
    activeStudents.push(...rows.filter(row => row.get('Nome')?.length > 0))

    // Verifica se esse mês já foi colocado na planilha. Se não foi, coloca.
    const header = sheet.headerValues
    if (!header.includes(monthYear)) {
      await sheet.setHeaderRow([...header, monthYear])
    }
  }))

  // Now go to the payments sheet to generate all payments
  const paymentsSheet = doc.sheetsByTitle['Pagamentos'];
  const allPayments = await paymentsSheet.getRows()

  const studentsToGenerate = activeStudents.filter(student => allPayments.filter(p => p.get('TurmaReferencia') === student._worksheet.title
    && p.get('MesReferencia') === monthYear && p.get('Nome') === student.get('Nome')
  ).length === 0)
  const studentsInputs = studentsToGenerate.map(student => ({
    Nome: student.get('Nome'),
    CPF: student.get('CPF'),
    Valor: valorMensalidade,
    DataVencimento: [student.get('DataVencimento'), month, year].join('/'),
    MesReferencia: monthYear,
    TurmaReferencia: student._worksheet.title
  }))

  await paymentsSheet.addRows(studentsInputs).then(pagamentos => pagamentos.forEach((pagamento, index) => {
    const student = activeStudents[index]
    pagamento.set("Status", `=IFS(H${pagamento.rowNumber}<>""; "PAGO"; HOJE() - D${pagamento.rowNumber} > 5; "ATRASADO"; TRUE; "PENDENTE")`)
    pagamento.save()
    // Create the link between the payment on this table and the original visialization table
    student.set(monthYear, `=Pagamentos!G${pagamento.rowNumber}`)
    student.save()
  }))

  // async function generateStudentPayment(index: number) {
  //   const student = activeStudents[index]
  //   if (!student) return

  //   // Before adding the payment, check if it already exists
  //   if (allPayments.filter(p => p.get('TurmaReferencia') === student._worksheet.title
  //     && p.get('MesReferencia') === monthYear && p.get('Nome') === student.get('Nome')
  //   ).length > 0) return generateStudentPayment(index + 1)

  //   await paymentsSheet.addRow({
  //     Nome: student.get('Nome'),
  //     CPF: student.get('CPF'),
  //     Valor: valorMensalidade,
  //     DataVencimento: [student.get('DataVencimento'), month, year].join('/'),
  //     MesReferencia: monthYear,
  //     TurmaReferencia: student._worksheet.title
  //   }).then(pagamento => {
  //     pagamento.set("Status", `=IFS(H${pagamento.rowNumber}<>""; "PAGO"; HOJE() - D${pagamento.rowNumber} > 5; "ATRASADO"; TRUE; "PENDENTE")`)
  //     pagamento.save()
  //     // Create the link between the payment on this table and the original visialization table
  //     student.set(monthYear, `=Pagamentos!G${pagamento.rowNumber}`)
  //     student.save()
  //   })

  //   return generateStudentPayment(index + 1)
  // }

  // await generateStudentPayment(0)
}

export async function updatePayments() {
  const doc = await getSheet()

  const gestaoSheet = doc.sheetsByTitle['Gestão'];
  await gestaoSheet.loadCells('Y115')
  const last_processed_tx_cell = gestaoSheet.getCellByA1('Y115')

  const { paymentsToUpdate, last_processed_tx } = await processPayments(
    null // typeof last_processed_tx_cell.value === 'string' ? last_processed_tx_cell.value : null
  )

  const paymentsSheet = doc.sheetsByTitle['Pagamentos'];
  const paymentsRows = await paymentsSheet.getRows()
  let unidentifiedPayments: typeof paymentsToUpdate = []
  paymentsToUpdate.forEach(async ({ transaction_id, nome, cpf, valor, dataPagamento }) => {
    // Find the payment corresponding to this processed payment
    const numberOfPaymentsToClear = Math.floor(valor / 130)
    const paymentsRowsFiltered = paymentsRows.filter(row =>
      isUndefined(row.get('DataPagamento')) &&
      compareCpf(cpf, row.get('CPF')) &&
      compareDates(row.get('MesReferencia'), dataPagamento)
    ).slice(0, numberOfPaymentsToClear)

    // If numberOfPaymentsToClear is lengthier than paymentsRowsFiltered found, we have an unidentified payment
    if (numberOfPaymentsToClear > paymentsRowsFiltered.length) {
      console.log('Unidentified payment')
      unidentifiedPayments.push({ transaction_id, nome, cpf, valor, dataPagamento })
      return
    }

    // Now update the actually processed payments
    const promises = paymentsRowsFiltered.map(async row => {
      row.set('Status', 'PAGO')
      row.set('DataPagamento', dataPagamento)
      row.set('TxId', transaction_id)
      row.set('CPFPagador', cpf)
      row.set('ProcessadoPelaApi', true)
      row.save()
    })
    await Promise.all(promises)
  })

  const naoIdentificadosSheet = doc.sheetsByTitle['Não Identificados'];
  async function processUnidentified(index: number) {
    if (index >= unidentifiedPayments.length) return

    const { transaction_id, nome, cpf, valor, dataPagamento } = unidentifiedPayments[index]
    await naoIdentificadosSheet.addRow({
      Nome: nome,
      CPF: cpf,
      Valor: valor,
      DataPagamento: dataPagamento,
      TxId: transaction_id
    })

    await processUnidentified(index + 1)
  }
  await processUnidentified(0)

  last_processed_tx_cell.value = last_processed_tx
  last_processed_tx_cell.save()
}

